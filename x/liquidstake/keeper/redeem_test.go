package keeper_test

import (
	"cosmossdk.io/math"
	"github.com/celinium-network/celinium/app"
	"github.com/celinium-network/celinium/x/liquidstake/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
)

func (suite *KeeperTestSuite) TestRedeemAfterUnbondingComplete() {
	sourceChainParams := suite.mockSourceChainParams()
	delegationEpochInfo := suite.delegationEpoch()
	suite.setSourceChainAndEpoch(sourceChainParams, delegationEpochInfo)

	testCoin := suite.testCoin
	controlChainApp := getCeliniumApp(suite.controlChain)
	ctlChainUserAccAddr := suite.controlChain.SenderAccount.GetAddress()
	ctlChainUserAddr := ctlChainUserAccAddr.String()

	ctx := suite.controlChain.GetContext()
	_, err := controlChainApp.LiquidStakeKeeper.Delegate(ctx, sourceChainParams.ChainID, testCoin.Amount, ctlChainUserAccAddr)
	suite.NoError(err)

	suite.advanceEpochAndRelayIBC(delegationEpochInfo)

	// user has already delegate, then undelegate
	unbondingEpochInfo := suite.unbondEpoch()
	ctx = suite.controlChain.GetContext()
	controlChainApp.EpochsKeeper.SetEpochInfo(ctx, *unbondingEpochInfo)
	suite.controlChain.Coordinator.IncrementTimeBy(unbondingEpochInfo.Duration)
	suite.transferPath.EndpointA.UpdateClient()

	ctx = suite.controlChain.GetContext()
	controlChainApp.LiquidStakeKeeper.Undelegate(ctx, sourceChainParams.ChainID, testCoin.Amount, ctlChainUserAccAddr)

	// process at next unbond epoch begin
	nextBlockTime := suite.advanceToNextEpoch(unbondingEpochInfo)
	_, nextBlockBeginRes := nextBlockWithRes(suite.controlChain, nextBlockTime)
	nextBlockWithRes(suite.sourceChain, nextBlockTime)

	suite.controlChain.NextBlock()
	suite.transferPath.EndpointA.UpdateClient()
	suite.relayIBCPacketFromCtlToSrc(nextBlockBeginRes.Events, ctlChainUserAddr)

	suite.WaitForUnbondingComplete(sourceChainParams, 2)

	ctx = suite.controlChain.GetContext()
	balBefore := controlChainApp.BankKeeper.GetBalance(ctx, ctlChainUserAccAddr, sourceChainParams.IbcDenom)
	_, err = controlChainApp.LiquidStakeKeeper.ClaimUnbonding(ctx, ctlChainUserAccAddr, 2, sourceChainParams.ChainID)
	balAfter := controlChainApp.BankKeeper.GetBalance(ctx, ctlChainUserAccAddr, sourceChainParams.IbcDenom)
	suite.NoError(err)
	suite.True(balAfter.Sub(balBefore).Amount.Equal(testCoin.Amount))
}

func (suite *KeeperTestSuite) TestUpdateRedeemRateWithMultiDelegationStatus() {
	amount := sdk.NewIntFromUint64(10000000)
	srcChainParams := suite.mockSourceChainParams()
	srcChainParams.StakedAmount = amount
	delegationEpochInfo := suite.delegationEpoch()

	suite.setSourceChainAndEpoch(srcChainParams, delegationEpochInfo)

	proxyDelegationTemplate := types.ProxyDelegation{
		Coin: sdk.Coin{
			Denom:  srcChainParams.NativeDenom,
			Amount: amount,
		},
		ChainID:        srcChainParams.ChainID,
		ReinvestAmount: math.ZeroInt(),
	}

	deriveAmt := math.ZeroInt()
	proxyDelegations := []types.ProxyDelegation{}
	testStaus := []types.ProxyDelegationStatus{
		types.ProxyDelegationPending,
		types.ProxyDelegationTransferring,
		types.ProxyDelegationTransferred,
		types.ProxyDelegating,
		types.ProxyDelegationDone,
		types.ProxyDelegationTransferFailed,
		types.ProxyDelegationFailed,
	}

	// Every delegation will generate `DerivativeToken`, unless it is generated by reinvestment
	for _, s := range testStaus {
		ds := proxyDelegationTemplate
		ds.Status = s
		proxyDelegations = append(proxyDelegations, ds)
		deriveAmt = deriveAmt.Add(amount)
	}

	// append reinvest delegation
	reinvestDelegation := proxyDelegationTemplate
	reinvestDelegation.ReinvestAmount = amount

	proxyDelegations = append(proxyDelegations, reinvestDelegation)

	controlChainApp := getCeliniumApp(suite.controlChain)
	ctx := suite.controlChain.GetContext()

	controlChainApp.BankKeeper.MintCoins(ctx, types.ModuleName, sdk.Coins{sdk.Coin{Denom: srcChainParams.DerivativeDenom, Amount: deriveAmt}})
	controlChainApp.LiquidStakeKeeper.UpdateRedeemRate(ctx, proxyDelegations)

	sourceChain, found := controlChainApp.LiquidStakeKeeper.GetSourceChain(ctx, srcChainParams.ChainID)
	suite.True(found)
	// rate should not be change, because reinvest delegation is pending.
	// The rate should be changed after reinvest delegataion done.
	// Otherwise, it may be oversubscribed during undelegation.
	suite.True(sourceChain.Redemptionratio.Equal(sdk.MustNewDecFromStr("1.0")))
}

func (suite *KeeperTestSuite) TestUpdateRedeemRateAfterEffect() {
	srcChainParams := suite.mockSourceChainParams()
	ctlChainApp := getCeliniumApp(suite.controlChain)
	ctx := suite.controlChain.GetContext()
	ctlAccAddr := suite.controlChain.SenderAccount.GetAddress()
	ctlAccAddr2 := suite.controlChain.SenderAccounts[2].SenderAccount.GetAddress()

	amount := sdk.NewIntFromUint64(10000000)
	delegationEpochInfo := suite.delegationEpoch()
	suite.setSourceChainAndEpoch(srcChainParams, delegationEpochInfo)

	suite.mockEnvAfterDelegate(srcChainParams, ctlChainApp, ctx, ctlAccAddr, amount)

	proxyDelegations := ctlChainApp.LiquidStakeKeeper.GetAllProxyDelegation(ctx)
	ctlChainApp.LiquidStakeKeeper.UpdateRedeemRate(ctx, proxyDelegations)

	sourceChain, found := ctlChainApp.LiquidStakeKeeper.GetSourceChain(ctx, srcChainParams.ChainID)
	suite.True(found)
	suite.True(sourceChain.Redemptionratio.Equal(sdk.MustNewDecFromStr("1.0")))

	suite.mockEnvAfterReinvest(srcChainParams, ctlChainApp, ctx, amount)
	proxyDelegations = ctlChainApp.LiquidStakeKeeper.GetAllProxyDelegation(ctx)
	ctlChainApp.LiquidStakeKeeper.UpdateRedeemRate(ctx, proxyDelegations)

	sourceChain, found = ctlChainApp.LiquidStakeKeeper.GetSourceChain(ctx, srcChainParams.ChainID)
	suite.True(found)
	suite.True(sourceChain.Redemptionratio.Equal(sdk.MustNewDecFromStr("2.0")))

	suite.mintTestCoin(ctlChainApp, ctx, sdk.Coin{
		Denom:  srcChainParams.IbcDenom,
		Amount: amount,
	}, ctlAccAddr2)

	_, err := ctlChainApp.LiquidStakeKeeper.Delegate(ctx, srcChainParams.ChainID, amount, ctlAccAddr2)
	suite.NoError(err)
	derivativeCoin := suite.getBalance(ctlChainApp, ctx, srcChainParams.DerivativeDenom, ctlAccAddr2)
	suite.True(derivativeCoin.Amount.Equal(amount.QuoRaw(2)))

	// create undelegate call complete env
	srcChainParams.StakedAmount = math.ZeroInt()
	suite.burnTestCoin(ctlChainApp, ctx, derivativeCoin, ctlAccAddr2)
	ctlAccAddrBalance := suite.getBalance(ctlChainApp, ctx, srcChainParams.DerivativeDenom, ctlAccAddr)
	suite.burnTestCoin(ctlChainApp, ctx, ctlAccAddrBalance, ctlAccAddr)
	ctlChainApp.LiquidStakeKeeper.UpdateRedeemRate(ctx, []types.ProxyDelegation{})

	// check ratio
	sourceChain, found = ctlChainApp.LiquidStakeKeeper.GetSourceChain(ctx, srcChainParams.ChainID)
	suite.True(found)
	suite.True(sourceChain.Redemptionratio.Equal(sdk.MustNewDecFromStr("1.0")))
}

func (suite *KeeperTestSuite) mockEnvAfterDelegate(srcChainParams *types.SourceChain,
	app *app.App, ctx sdk.Context, delegator sdk.AccAddress, amount math.Int,
) {
	proxyDelegation := types.ProxyDelegation{
		Coin: sdk.Coin{
			Denom:  srcChainParams.NativeDenom,
			Amount: amount,
		},
		ChainID:        srcChainParams.ChainID,
		ReinvestAmount: math.ZeroInt(),
		Status:         types.ProxyDelegationDone,
	}
	srcChainParams.StakedAmount = srcChainParams.StakedAmount.Add(amount)

	id := app.LiquidStakeKeeper.GetProxyDelegationID(ctx)
	app.LiquidStakeKeeper.IncreaseProxyDelegationID(ctx)
	app.LiquidStakeKeeper.SetProxyDelegation(ctx, id, &proxyDelegation)
	app.LiquidStakeKeeper.SetSourceChain(ctx, srcChainParams)

	derivativeAmt := sdk.NewDecFromInt(amount).Quo(srcChainParams.Redemptionratio).TruncateInt()

	derivativeCoin := sdk.Coin{
		Denom:  srcChainParams.DerivativeDenom,
		Amount: derivativeAmt,
	}
	app.BankKeeper.MintCoins(ctx, types.ModuleName, sdk.Coins{derivativeCoin})
	app.BankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, delegator, sdk.Coins{derivativeCoin})
}

func (suite *KeeperTestSuite) mockEnvAfterReinvest(srcChainParams *types.SourceChain, app *app.App, ctx sdk.Context, amount math.Int) {
	proxyDelegation := types.ProxyDelegation{
		Coin: sdk.Coin{
			Denom:  srcChainParams.NativeDenom,
			Amount: amount,
		},
		ChainID:        srcChainParams.ChainID,
		ReinvestAmount: amount,
		Status:         types.ProxyDelegationDone,
	}
	srcChainParams.StakedAmount = srcChainParams.StakedAmount.Add(amount)

	id := app.LiquidStakeKeeper.GetProxyDelegationID(ctx)
	app.LiquidStakeKeeper.IncreaseProxyDelegationID(ctx)
	app.LiquidStakeKeeper.SetProxyDelegation(ctx, id, &proxyDelegation)
	app.LiquidStakeKeeper.SetSourceChain(ctx, srcChainParams)
}

func (suite *KeeperTestSuite) mintTestCoin(app *app.App, ctx sdk.Context, coin sdk.Coin, dest sdk.AccAddress) {
	app.BankKeeper.MintCoins(ctx, types.ModuleName, sdk.Coins{coin})
	app.BankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, dest, sdk.Coins{coin})
}

func (suite *KeeperTestSuite) burnTestCoin(app *app.App, ctx sdk.Context, coin sdk.Coin, dest sdk.AccAddress) {
	app.BankKeeper.SendCoinsFromAccountToModule(ctx, dest, types.ModuleName, sdk.Coins{coin})
	app.BankKeeper.BurnCoins(ctx, types.ModuleName, sdk.Coins{coin})
}

func (suite *KeeperTestSuite) getBalance(app *app.App, ctx sdk.Context, denom string, dest sdk.AccAddress) sdk.Coin {
	return app.BankKeeper.GetBalance(ctx, dest, denom)
}
