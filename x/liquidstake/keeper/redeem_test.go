package keeper_test

import (
	"cosmossdk.io/math"
	"github.com/celinium-network/celinium/x/liquidstake/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
)

func (suite *KeeperTestSuite) TestRedeemAfterUnbondingComplete() {
	sourceChainParams := suite.generateSourceChainParams()
	delegationEpochInfo := suite.delegationEpoch()
	suite.setSourceChainAndEpoch(sourceChainParams, delegationEpochInfo)

	testCoin := suite.testCoin
	controlChainApp := getCeliniumApp(suite.controlChain)
	ctlChainUserAccAddr := suite.controlChain.SenderAccount.GetAddress()
	ctlChainUserAddr := ctlChainUserAccAddr.String()

	ctx := suite.controlChain.GetContext()
	_, err := controlChainApp.LiquidStakeKeeper.Delegate(ctx, sourceChainParams.ChainID, testCoin.Amount, ctlChainUserAccAddr)
	suite.NoError(err)

	suite.advanceEpochAndRelayIBC(delegationEpochInfo)

	// user has already delegate, then undelegate
	unbondingEpochInfo := suite.unbondEpoch()
	ctx = suite.controlChain.GetContext()
	controlChainApp.EpochsKeeper.SetEpochInfo(ctx, *unbondingEpochInfo)
	suite.controlChain.Coordinator.IncrementTimeBy(unbondingEpochInfo.Duration)
	suite.transferPath.EndpointA.UpdateClient()

	ctx = suite.controlChain.GetContext()
	controlChainApp.LiquidStakeKeeper.Undelegate(ctx, sourceChainParams.ChainID, testCoin.Amount, ctlChainUserAccAddr)

	// process at next unbond epoch begin
	nextBlockTime := suite.advanceToNextEpoch(unbondingEpochInfo)
	_, nextBlockBeginRes := nextBlockWithRes(suite.controlChain, nextBlockTime)
	nextBlockWithRes(suite.sourceChain, nextBlockTime)

	suite.controlChain.NextBlock()
	suite.transferPath.EndpointA.UpdateClient()
	suite.relayIBCPacketFromCtlToSrc(nextBlockBeginRes.Events, ctlChainUserAddr)

	suite.WaitForUnbondingComplete(sourceChainParams, 2)

	ctx = suite.controlChain.GetContext()
	balBefore := controlChainApp.BankKeeper.GetBalance(ctx, ctlChainUserAccAddr, sourceChainParams.IbcDenom)
	_, err = controlChainApp.LiquidStakeKeeper.ClaimUnbonding(ctx, ctlChainUserAccAddr, 2, sourceChainParams.ChainID)
	balAfter := controlChainApp.BankKeeper.GetBalance(ctx, ctlChainUserAccAddr, sourceChainParams.IbcDenom)
	suite.NoError(err)
	suite.True(balAfter.Sub(balBefore).Amount.Equal(testCoin.Amount))
}

func (suite *KeeperTestSuite) TestUpdateRedeemRateWithMultiDelegationStatus() {
	// different delegation status => expect rate
	amount := sdk.NewIntFromUint64(10000000)
	srcChainParams := suite.generateSourceChainParams()
	srcChainParams.StakedAmount = amount
	delegationEpochInfo := suite.delegationEpoch()

	suite.setSourceChainAndEpoch(srcChainParams, delegationEpochInfo)

	proxyDelegationTemplate := types.ProxyDelegation{
		Id: 0,
		Coin: sdk.Coin{
			Denom:  srcChainParams.NativeDenom,
			Amount: amount,
		},
		EpochNumber:    0,
		ChainID:        srcChainParams.ChainID,
		ReinvestAmount: math.ZeroInt(),
	}

	deriveAmt := math.ZeroInt()
	proxyDelegations := []types.ProxyDelegation{}
	testStaus := []types.ProxyDelegationStatus{
		types.ProxyDelegationPending,
		types.ProxyDelegationTransferring,
		types.ProxyDelegationTransferred,
		types.ProxyDelegating,
		types.ProxyDelegationDone,
		types.ProxyDelegationTransferFailed,
		types.ProxyDelegationFailed,
	}

	// Every delegation will generate `DerivativeToken`, unless it is generated by reinvestment
	for _, s := range testStaus {
		ds := proxyDelegationTemplate
		ds.Status = s
		proxyDelegations = append(proxyDelegations, ds)
		deriveAmt = deriveAmt.Add(amount)
	}

	// append reinvest delegation
	reinvestDelegation := proxyDelegationTemplate
	reinvestDelegation.ReinvestAmount = amount

	proxyDelegations = append(proxyDelegations, reinvestDelegation)

	controlChainApp := getCeliniumApp(suite.controlChain)
	ctx := suite.controlChain.GetContext()

	controlChainApp.BankKeeper.MintCoins(ctx, types.ModuleName, sdk.Coins{sdk.Coin{Denom: srcChainParams.DerivativeDenom, Amount: deriveAmt}})
	controlChainApp.LiquidStakeKeeper.UpdateRedeemRate(ctx, proxyDelegations)

	sourceChain, found := controlChainApp.LiquidStakeKeeper.GetSourceChain(ctx, srcChainParams.ChainID)
	suite.True(found)
	// rate should not be change, because reinvest delegation is pending.
	// The rate should be changed after reinvest delegataion done.
	// Otherwise, it may be oversubscribed during undelegation.
	sourceChain.Redemptionratio.Equal(sdk.MustNewDecFromStr("1.0"))
}

func (suite *KeeperTestSuite) TestUpdateRedeemRateAfterUndelegate() {
	// step1: rate 1
	// step2: rate 1.5
	// step3: undelegate
	// step4: rate 1.2
	// step5: undelegate all => rate 1:1
}
