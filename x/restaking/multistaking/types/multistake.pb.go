// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: celinium/restaking/multistake/v1/multistake.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MultiStakingDenomWhiteList struct {
	DenomList []string `protobuf:"bytes,1,rep,name=denom_list,json=denomList,proto3" json:"denom_list,omitempty"`
}

func (m *MultiStakingDenomWhiteList) Reset()         { *m = MultiStakingDenomWhiteList{} }
func (m *MultiStakingDenomWhiteList) String() string { return proto.CompactTextString(m) }
func (*MultiStakingDenomWhiteList) ProtoMessage()    {}
func (*MultiStakingDenomWhiteList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1f1a8026a27605f, []int{0}
}
func (m *MultiStakingDenomWhiteList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingDenomWhiteList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingDenomWhiteList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingDenomWhiteList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingDenomWhiteList.Merge(m, src)
}
func (m *MultiStakingDenomWhiteList) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingDenomWhiteList) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingDenomWhiteList.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingDenomWhiteList proto.InternalMessageInfo

func (m *MultiStakingDenomWhiteList) GetDenomList() []string {
	if m != nil {
		return m.DenomList
	}
	return nil
}

type EquivalentMultiplierRecord struct {
	EpochNumber int64  `protobuf:"varint,1,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty"`
	Denom       string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Multiplier  Dec    `protobuf:"bytes,3,opt,name=multiplier,proto3,customtype=Dec" json:"multiplier"`
}

func (m *EquivalentMultiplierRecord) Reset()         { *m = EquivalentMultiplierRecord{} }
func (m *EquivalentMultiplierRecord) String() string { return proto.CompactTextString(m) }
func (*EquivalentMultiplierRecord) ProtoMessage()    {}
func (*EquivalentMultiplierRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1f1a8026a27605f, []int{1}
}
func (m *EquivalentMultiplierRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquivalentMultiplierRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquivalentMultiplierRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquivalentMultiplierRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquivalentMultiplierRecord.Merge(m, src)
}
func (m *EquivalentMultiplierRecord) XXX_Size() int {
	return m.Size()
}
func (m *EquivalentMultiplierRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_EquivalentMultiplierRecord.DiscardUnknown(m)
}

var xxx_messageInfo_EquivalentMultiplierRecord proto.InternalMessageInfo

func (m *EquivalentMultiplierRecord) GetEpochNumber() int64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *EquivalentMultiplierRecord) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MultiStakingDelegation struct {
	DelegatorAddress       string      `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
	ValidatorAddress       string      `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	DelegationAmount       types.Coin  `protobuf:"bytes,3,opt,name=delegation_amount,json=delegationAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"delegation_amount"`
	EquivalentStakedAmount *types.Coin `protobuf:"bytes,4,opt,name=equivalent_staked_amount,json=equivalentStakedAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"equivalent_staked_amount,omitempty"`
}

func (m *MultiStakingDelegation) Reset()         { *m = MultiStakingDelegation{} }
func (m *MultiStakingDelegation) String() string { return proto.CompactTextString(m) }
func (*MultiStakingDelegation) ProtoMessage()    {}
func (*MultiStakingDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1f1a8026a27605f, []int{2}
}
func (m *MultiStakingDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingDelegation.Merge(m, src)
}
func (m *MultiStakingDelegation) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingDelegation proto.InternalMessageInfo

func (m *MultiStakingDelegation) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *MultiStakingDelegation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MultiStakingDelegation) GetDelegationAmount() types.Coin {
	if m != nil {
		return m.DelegationAmount
	}
	return types.Coin{}
}

func (m *MultiStakingDelegation) GetEquivalentStakedAmount() *types.Coin {
	if m != nil {
		return m.EquivalentStakedAmount
	}
	return nil
}

type MultiStakingAgent struct {
	Id                    uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StakeDeonm            string `protobuf:"bytes,2,opt,name=stake_deonm,json=stakeDeonm,proto3" json:"stake_deonm,omitempty"`
	AgentDelegatorAddress string `protobuf:"bytes,3,opt,name=agent_delegator_address,json=agentDelegatorAddress,proto3" json:"agent_delegator_address,omitempty"`
	WithdrawAddress       string `protobuf:"bytes,4,opt,name=withdraw_address,json=withdrawAddress,proto3" json:"withdraw_address,omitempty"`
	StakedAmount          Int    `protobuf:"bytes,5,opt,name=staked_amount,json=stakedAmount,proto3,customtype=Int" json:"staked_amount"`
	RewardAmount          Int    `protobuf:"bytes,6,opt,name=reward_amount,json=rewardAmount,proto3,customtype=Int" json:"reward_amount"`
}

func (m *MultiStakingAgent) Reset()         { *m = MultiStakingAgent{} }
func (m *MultiStakingAgent) String() string { return proto.CompactTextString(m) }
func (*MultiStakingAgent) ProtoMessage()    {}
func (*MultiStakingAgent) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1f1a8026a27605f, []int{3}
}
func (m *MultiStakingAgent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingAgent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingAgent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingAgent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingAgent.Merge(m, src)
}
func (m *MultiStakingAgent) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingAgent) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingAgent.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingAgent proto.InternalMessageInfo

func (m *MultiStakingAgent) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MultiStakingAgent) GetStakeDeonm() string {
	if m != nil {
		return m.StakeDeonm
	}
	return ""
}

func (m *MultiStakingAgent) GetAgentDelegatorAddress() string {
	if m != nil {
		return m.AgentDelegatorAddress
	}
	return ""
}

func (m *MultiStakingAgent) GetWithdrawAddress() string {
	if m != nil {
		return m.WithdrawAddress
	}
	return ""
}

type MultiStakingUnbonding struct {
	Id               uint32                       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AgentorId        uint32                       `protobuf:"varint,2,opt,name=agentor_id,json=agentorId,proto3" json:"agentor_id,omitempty"`
	DelegatorAddress string                       `protobuf:"bytes,3,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
	Entries          []MultiStakingUnbondingEntry `protobuf:"bytes,4,rep,name=entries,proto3" json:"entries"`
}

func (m *MultiStakingUnbonding) Reset()         { *m = MultiStakingUnbonding{} }
func (m *MultiStakingUnbonding) String() string { return proto.CompactTextString(m) }
func (*MultiStakingUnbonding) ProtoMessage()    {}
func (*MultiStakingUnbonding) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1f1a8026a27605f, []int{4}
}
func (m *MultiStakingUnbonding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingUnbonding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingUnbonding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingUnbonding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingUnbonding.Merge(m, src)
}
func (m *MultiStakingUnbonding) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingUnbonding) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingUnbonding.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingUnbonding proto.InternalMessageInfo

func (m *MultiStakingUnbonding) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MultiStakingUnbonding) GetAgentorId() uint32 {
	if m != nil {
		return m.AgentorId
	}
	return 0
}

func (m *MultiStakingUnbonding) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *MultiStakingUnbonding) GetEntries() []MultiStakingUnbondingEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type MultiStakingUnbondingEntry struct {
	CompletionTime time.Time   `protobuf:"bytes,1,opt,name=completion_time,json=completionTime,proto3,stdtime" json:"completion_time"`
	InitialBalance *types.Coin `protobuf:"bytes,2,opt,name=initial_balance,json=initialBalance,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"initial_balance,omitempty"`
	Balance        *types.Coin `protobuf:"bytes,3,opt,name=balance,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"balance,omitempty"`
}

func (m *MultiStakingUnbondingEntry) Reset()         { *m = MultiStakingUnbondingEntry{} }
func (m *MultiStakingUnbondingEntry) String() string { return proto.CompactTextString(m) }
func (*MultiStakingUnbondingEntry) ProtoMessage()    {}
func (*MultiStakingUnbondingEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1f1a8026a27605f, []int{5}
}
func (m *MultiStakingUnbondingEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingUnbondingEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingUnbondingEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingUnbondingEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingUnbondingEntry.Merge(m, src)
}
func (m *MultiStakingUnbondingEntry) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingUnbondingEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingUnbondingEntry.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingUnbondingEntry proto.InternalMessageInfo

func (m *MultiStakingUnbondingEntry) GetCompletionTime() time.Time {
	if m != nil {
		return m.CompletionTime
	}
	return time.Time{}
}

func (m *MultiStakingUnbondingEntry) GetInitialBalance() *types.Coin {
	if m != nil {
		return m.InitialBalance
	}
	return nil
}

func (m *MultiStakingUnbondingEntry) GetBalance() *types.Coin {
	if m != nil {
		return m.Balance
	}
	return nil
}

func init() {
	proto.RegisterType((*MultiStakingDenomWhiteList)(nil), "celinium.restaking.multistake.v1.MultiStakingDenomWhiteList")
	proto.RegisterType((*EquivalentMultiplierRecord)(nil), "celinium.restaking.multistake.v1.EquivalentMultiplierRecord")
	proto.RegisterType((*MultiStakingDelegation)(nil), "celinium.restaking.multistake.v1.MultiStakingDelegation")
	proto.RegisterType((*MultiStakingAgent)(nil), "celinium.restaking.multistake.v1.MultiStakingAgent")
	proto.RegisterType((*MultiStakingUnbonding)(nil), "celinium.restaking.multistake.v1.MultiStakingUnbonding")
	proto.RegisterType((*MultiStakingUnbondingEntry)(nil), "celinium.restaking.multistake.v1.MultiStakingUnbondingEntry")
}

func init() {
	proto.RegisterFile("celinium/restaking/multistake/v1/multistake.proto", fileDescriptor_d1f1a8026a27605f)
}

var fileDescriptor_d1f1a8026a27605f = []byte{
	// 773 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6a, 0xdb, 0x4a,
	0x14, 0xb6, 0xec, 0xfc, 0x5c, 0x8f, 0xf3, 0x2b, 0x92, 0x5c, 0xc7, 0x10, 0xdb, 0xd7, 0x9b, 0x18,
	0x42, 0x24, 0x9c, 0xbb, 0x2a, 0x2d, 0x05, 0x3b, 0xce, 0x22, 0xd0, 0x94, 0xa2, 0xb4, 0x14, 0x4a,
	0x41, 0x95, 0x34, 0x53, 0x79, 0x88, 0x34, 0xe3, 0x8e, 0xc6, 0x76, 0xb3, 0xeb, 0x23, 0xe4, 0x39,
	0xba, 0xce, 0xba, 0xeb, 0x2c, 0x43, 0x56, 0xa5, 0x85, 0xa4, 0x24, 0xcb, 0x42, 0x9f, 0xa1, 0xcc,
	0x8c, 0xa4, 0xc8, 0x4d, 0xc0, 0x14, 0xb2, 0xb2, 0xcf, 0xdf, 0x77, 0xbe, 0xf9, 0xce, 0xcc, 0x11,
	0x68, 0x79, 0x28, 0xc0, 0x04, 0x0f, 0x42, 0x93, 0xa1, 0x88, 0x3b, 0x47, 0x98, 0xf8, 0x66, 0x38,
	0x08, 0x38, 0x16, 0x06, 0x32, 0x87, 0xad, 0x8c, 0x65, 0xf4, 0x19, 0xe5, 0x54, 0xaf, 0x27, 0x25,
	0x46, 0x5a, 0x62, 0x64, 0x92, 0x86, 0xad, 0x4a, 0xcd, 0xa7, 0xd4, 0x0f, 0x90, 0x29, 0xf3, 0xdd,
	0xc1, 0x7b, 0x93, 0xe3, 0x50, 0xa4, 0x86, 0x7d, 0x05, 0x51, 0x59, 0xf1, 0xa9, 0x4f, 0xe5, 0x5f,
	0x53, 0xfc, 0x8b, 0xbd, 0xeb, 0x1e, 0x8d, 0x42, 0x1a, 0xd9, 0x2a, 0xa0, 0x8c, 0x38, 0x54, 0x55,
	0x96, 0xe9, 0x3a, 0x91, 0x20, 0xe5, 0x22, 0xee, 0xb4, 0x4c, 0x8f, 0x62, 0xa2, 0xe2, 0x8d, 0xc7,
	0xa0, 0x72, 0x20, 0x28, 0x1c, 0x2a, 0x3e, 0x5d, 0x44, 0x68, 0xf8, 0xba, 0x87, 0x39, 0x7a, 0x86,
	0x23, 0xae, 0x6f, 0x00, 0x00, 0x85, 0xc7, 0x0e, 0x70, 0xc4, 0xcb, 0x5a, 0xbd, 0xd0, 0x2c, 0x5a,
	0x45, 0xe9, 0x11, 0xe1, 0xc6, 0x89, 0x06, 0x2a, 0x7b, 0x1f, 0x06, 0x78, 0xe8, 0x04, 0x88, 0x70,
	0x89, 0xd3, 0x0f, 0x30, 0x62, 0x16, 0xf2, 0x28, 0x83, 0xfa, 0x7f, 0x60, 0x0e, 0xf5, 0xa9, 0xd7,
	0xb3, 0xc9, 0x20, 0x74, 0x11, 0x2b, 0x6b, 0x75, 0xad, 0x59, 0xb0, 0x4a, 0xd2, 0xf7, 0x5c, 0xba,
	0xf4, 0x15, 0x30, 0x2d, 0xe1, 0xca, 0xf9, 0xba, 0xd6, 0x2c, 0x5a, 0xca, 0xd0, 0x1f, 0x01, 0x10,
	0xa6, 0x60, 0xe5, 0x82, 0x08, 0x75, 0xd6, 0xcf, 0x2e, 0x6b, 0xb9, 0x6f, 0x97, 0xb5, 0x42, 0x17,
	0x79, 0x17, 0xa7, 0xdb, 0x20, 0x3e, 0x65, 0x17, 0x79, 0x56, 0x26, 0xb9, 0xf1, 0x2b, 0x0f, 0xd6,
	0xc6, 0x0f, 0x14, 0x20, 0xdf, 0xe1, 0x98, 0x12, 0x7d, 0x0b, 0x2c, 0x43, 0x65, 0x51, 0x66, 0x3b,
	0x10, 0x32, 0x14, 0x45, 0x92, 0x53, 0xd1, 0x5a, 0x4a, 0x03, 0x6d, 0xe5, 0x17, 0xc9, 0x43, 0x27,
	0xc0, 0x70, 0x2c, 0x59, 0x91, 0x5c, 0x4a, 0x03, 0x49, 0xf2, 0x28, 0x45, 0xc6, 0x94, 0xd8, 0x4e,
	0x48, 0x07, 0x84, 0x4b, 0xda, 0xa5, 0x9d, 0x75, 0x23, 0x26, 0x2a, 0x06, 0x60, 0xc4, 0x03, 0x30,
	0x76, 0x29, 0x26, 0x1d, 0x53, 0x9c, 0xe8, 0xf3, 0x55, 0x6d, 0xd3, 0xc7, 0xbc, 0x37, 0x70, 0x0d,
	0x8f, 0x86, 0xf1, 0xec, 0xe2, 0x9f, 0xed, 0x08, 0x1e, 0x99, 0xfc, 0xb8, 0x8f, 0x22, 0x59, 0x90,
	0xb2, 0xc4, 0x94, 0xb4, 0x65, 0x0f, 0xfd, 0x93, 0x06, 0xca, 0x28, 0x1d, 0x80, 0x2d, 0xef, 0x11,
	0x4c, 0x08, 0x4c, 0x4d, 0x22, 0xb0, 0xf5, 0x37, 0xcd, 0xd7, 0x6e, 0xfb, 0x1c, 0xca, 0x36, 0x8a,
	0x42, 0xe3, 0x7b, 0x1e, 0x2c, 0x67, 0x05, 0x6f, 0xfb, 0x88, 0x70, 0x7d, 0x01, 0xe4, 0x31, 0x94,
	0xe2, 0xce, 0x5b, 0x79, 0x0c, 0xf5, 0x1a, 0x28, 0x49, 0x72, 0x36, 0x44, 0x94, 0x24, 0xd3, 0x06,
	0xd2, 0xd5, 0x15, 0x1e, 0xfd, 0x05, 0xf8, 0xd7, 0x11, 0x95, 0xf6, 0xdd, 0x11, 0xa9, 0xf9, 0x97,
	0x2f, 0x4e, 0xb7, 0x57, 0xe2, 0xa3, 0xc4, 0xba, 0x1f, 0x72, 0x86, 0x89, 0x6f, 0xad, 0xca, 0xc2,
	0xee, 0x9f, 0x13, 0xdc, 0x05, 0x4b, 0x23, 0xcc, 0x7b, 0x90, 0x39, 0xa3, 0x14, 0x6a, 0x6a, 0x02,
	0xd4, 0x62, 0x52, 0x91, 0x80, 0x3c, 0x05, 0xf3, 0xe3, 0xa2, 0x4e, 0x8f, 0x5f, 0xc6, 0x7d, 0xc2,
	0x33, 0x97, 0x71, 0x9f, 0x70, 0x6b, 0x2e, 0xca, 0xa8, 0x23, 0xea, 0x19, 0x1a, 0x39, 0x2c, 0xad,
	0x9f, 0x99, 0x58, 0xaf, 0xf2, 0x63, 0x75, 0x7f, 0x6a, 0x60, 0x35, 0xab, 0xee, 0x2b, 0xe2, 0x52,
	0x02, 0x31, 0xf1, 0xef, 0x28, 0xbc, 0x01, 0x80, 0xd4, 0x81, 0x32, 0x1b, 0x43, 0x29, 0xf0, 0xbc,
	0x55, 0x8c, 0x3d, 0xfb, 0x50, 0xdf, 0xbb, 0xef, 0xf2, 0x4f, 0x52, 0xf6, 0xee, 0xb3, 0x78, 0x0b,
	0x66, 0x11, 0xe1, 0x0c, 0x23, 0xa1, 0x65, 0xa1, 0x59, 0xda, 0x79, 0x62, 0x4c, 0x5a, 0x6a, 0xc6,
	0xbd, 0xfc, 0xf7, 0x08, 0x67, 0xc7, 0x9d, 0x29, 0xa1, 0x83, 0x95, 0x40, 0x36, 0xbe, 0xe4, 0xc7,
	0xb7, 0xd1, 0x78, 0xb6, 0x7e, 0x00, 0x16, 0x3d, 0x1a, 0xf6, 0x03, 0x24, 0x9f, 0x99, 0x58, 0x8d,
	0xf2, 0xfc, 0xa5, 0x9d, 0x8a, 0xa1, 0xf6, 0xa6, 0x91, 0xec, 0x4d, 0xe3, 0x65, 0xb2, 0x37, 0x3b,
	0xff, 0x88, 0x16, 0x27, 0x57, 0x35, 0xcd, 0x5a, 0xb8, 0x2d, 0x16, 0x61, 0x9d, 0x82, 0x45, 0x4c,
	0x30, 0xc7, 0x4e, 0x60, 0xbb, 0x4e, 0xe0, 0x10, 0x0f, 0x49, 0xd9, 0x1e, 0xee, 0xc9, 0x2c, 0xc4,
	0xf0, 0x1d, 0x85, 0xae, 0xbf, 0x03, 0xb3, 0x49, 0xa3, 0xc2, 0x83, 0x36, 0x4a, 0x60, 0x3b, 0xed,
	0xb3, 0xeb, 0xaa, 0x76, 0x7e, 0x5d, 0xd5, 0x7e, 0x5c, 0x57, 0xb5, 0x93, 0x9b, 0x6a, 0xee, 0xfc,
	0xa6, 0x9a, 0xfb, 0x7a, 0x53, 0xcd, 0xbd, 0xd9, 0x4c, 0x3f, 0x57, 0x1f, 0xef, 0xfb, 0x60, 0x09,
	0x43, 0x02, 0xba, 0x33, 0x52, 0xc3, 0xff, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x3c, 0xac,
	0x46, 0xe0, 0x06, 0x00, 0x00,
}

func (m *MultiStakingDenomWhiteList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingDenomWhiteList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingDenomWhiteList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DenomList) > 0 {
		for iNdEx := len(m.DenomList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DenomList[iNdEx])
			copy(dAtA[i:], m.DenomList[iNdEx])
			i = encodeVarintMultistake(dAtA, i, uint64(len(m.DenomList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EquivalentMultiplierRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquivalentMultiplierRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EquivalentMultiplierRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Multiplier.Size()
		i -= size
		if _, err := m.Multiplier.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.EpochNumber != 0 {
		i = encodeVarintMultistake(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiStakingDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EquivalentStakedAmount != nil {
		{
			size, err := m.EquivalentStakedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMultistake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.DelegationAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiStakingAgent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingAgent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingAgent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RewardAmount.Size()
		i -= size
		if _, err := m.RewardAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.StakedAmount.Size()
		i -= size
		if _, err := m.StakedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.WithdrawAddress) > 0 {
		i -= len(m.WithdrawAddress)
		copy(dAtA[i:], m.WithdrawAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.WithdrawAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AgentDelegatorAddress) > 0 {
		i -= len(m.AgentDelegatorAddress)
		copy(dAtA[i:], m.AgentDelegatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.AgentDelegatorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StakeDeonm) > 0 {
		i -= len(m.StakeDeonm)
		copy(dAtA[i:], m.StakeDeonm)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.StakeDeonm)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintMultistake(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiStakingUnbonding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingUnbonding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingUnbonding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMultistake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AgentorId != 0 {
		i = encodeVarintMultistake(dAtA, i, uint64(m.AgentorId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintMultistake(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiStakingUnbondingEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingUnbondingEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingUnbondingEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMultistake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InitialBalance != nil {
		{
			size, err := m.InitialBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMultistake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CompletionTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CompletionTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintMultistake(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintMultistake(dAtA []byte, offset int, v uint64) int {
	offset -= sovMultistake(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MultiStakingDenomWhiteList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DenomList) > 0 {
		for _, s := range m.DenomList {
			l = len(s)
			n += 1 + l + sovMultistake(uint64(l))
		}
	}
	return n
}

func (m *EquivalentMultiplierRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNumber != 0 {
		n += 1 + sovMultistake(uint64(m.EpochNumber))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = m.Multiplier.Size()
	n += 1 + l + sovMultistake(uint64(l))
	return n
}

func (m *MultiStakingDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = m.DelegationAmount.Size()
	n += 1 + l + sovMultistake(uint64(l))
	if m.EquivalentStakedAmount != nil {
		l = m.EquivalentStakedAmount.Size()
		n += 1 + l + sovMultistake(uint64(l))
	}
	return n
}

func (m *MultiStakingAgent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMultistake(uint64(m.Id))
	}
	l = len(m.StakeDeonm)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = len(m.AgentDelegatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = len(m.WithdrawAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = m.StakedAmount.Size()
	n += 1 + l + sovMultistake(uint64(l))
	l = m.RewardAmount.Size()
	n += 1 + l + sovMultistake(uint64(l))
	return n
}

func (m *MultiStakingUnbonding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMultistake(uint64(m.Id))
	}
	if m.AgentorId != 0 {
		n += 1 + sovMultistake(uint64(m.AgentorId))
	}
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovMultistake(uint64(l))
		}
	}
	return n
}

func (m *MultiStakingUnbondingEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CompletionTime)
	n += 1 + l + sovMultistake(uint64(l))
	if m.InitialBalance != nil {
		l = m.InitialBalance.Size()
		n += 1 + l + sovMultistake(uint64(l))
	}
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovMultistake(uint64(l))
	}
	return n
}

func sovMultistake(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMultistake(x uint64) (n int) {
	return sovMultistake(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MultiStakingDenomWhiteList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingDenomWhiteList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingDenomWhiteList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomList = append(m.DenomList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquivalentMultiplierRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquivalentMultiplierRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquivalentMultiplierRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Multiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStakingDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquivalentStakedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EquivalentStakedAmount == nil {
				m.EquivalentStakedAmount = &types.Coin{}
			}
			if err := m.EquivalentStakedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStakingAgent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingAgent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingAgent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeDeonm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakeDeonm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentDelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentDelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStakingUnbonding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingUnbonding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingUnbonding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentorId", wireType)
			}
			m.AgentorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentorId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, MultiStakingUnbondingEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStakingUnbondingEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingUnbondingEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingUnbondingEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CompletionTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitialBalance == nil {
				m.InitialBalance = &types.Coin{}
			}
			if err := m.InitialBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &types.Coin{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMultistake(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMultistake
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMultistake
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMultistake
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMultistake        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMultistake          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMultistake = fmt.Errorf("proto: unexpected end of group")
)
